{"config":{"lang":["de"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Startseite","text":"<p>Dies ist die Dokumentation \u00fcber PHP, in welcher die Grundschritte und wichtige Methoden beschrieben werden.</p>"},{"location":"index.html#inhaltsverzeichnis","title":"Inhaltsverzeichnis","text":"<p>Diese Seite enth\u00e4lt ein Inhaltsverzeichnis, welche die Seiten kategorisiert. Das Verzeichnis hilft zur schnellen Navigation, da gewisse Aufgaben zusammen genommen wurden.</p>"},{"location":"index.html#vorschau-modulprufung-183","title":"Vorschau Modulpr\u00fcfung 183","text":"<p>Die Modulpr\u00fcfung am Mi 2024-05-29 besteht aus einem theoretischen und einem praktischen Teil, wobei der Schwerpunkt auf dem praktischen Teil liegt. Um Fragen aus dem praktischen Teil beantworten zu k\u00f6nnen, m\u00fcssen Sie m\u00f6glicherweise OpenSSL nutzen. Pr\u00fcfen Sie, ob dies in Ihrem Browser l\u00e4uft. F\u00fcr OpenSSL sollten Sie diese beiden Dokumente parat haben:</p> <ul> <li>Wichtige OpenSSL-Commands</li> <li>OpenSSL-How-To</li> </ul> <p>F\u00fcr den praktischen Teil ist man bestens vorbereitet, wenn man die \u00dcbungsaufgaben zu JWT-Tokens gel\u00f6st hat.</p> <p>Sie werden an der Pr\u00fcfung ein GitHub-Classroom-Assignment erhalten, mit dem Sie Ihr pers\u00f6nliches Pr\u00fcfungs-Repo erstellen k\u00f6nnen. Daneben m\u00fcssen Sie eine Mysql-Datenbank mit einem leeren Schema parat haben.</p> <p>Im praktischen Teil werden Ihnen Unit-Tests zur Verf\u00fcgung gestellt. Die Bewertung des praktischen Teils geschieht ausschliesslich auf Basis dieser Unit-Tests. Es kann f\u00fcr Sie eine grosse Hilfe sein, wenn Sie Postman parat haben. Die Unit-Tests k\u00f6nnen zwar ohne Postman ausgef\u00fchrt werden, sie k\u00f6nnen aber in Postman importiert werden. Damit haben Sie Einblick in das \"Innenleben\" der Tests.</p>"},{"location":"Praxis/ErrorHandling.html","title":"Error Handling","text":"<p>Effektives Error Handling ist entscheidend f\u00fcr die Sicherheit und Zuverl\u00e4ssigkeit von Anwendungen. Es sch\u00fctzt vor unvorhergesehenen Abst\u00fcrzen und verhindert, dass sensible Informationen an Benutzer weitergegeben werden. (Information Disclosure)</p> Error Handling Middleware<pre><code>api.use((err, req, res, next) =&gt; {\n    console.error(err.message);\n    res.status(err.statusCode || 500).json({ errorMessage: err.message });\n});\n</code></pre> Error Handling mit Information Disclosure<pre><code>api.use((err, req, res, next) =&gt; {\n    logger.error(err.message, {\n        errno: err.errno,\n        error: err,\n    });\n    err.statusCode ??= HTTP_STATUS_INETERNAL_SERVER_ERROR;\n    if (err.statusCode === HTTP_STATUS_INETERNAL_SERVER_ERROR) {\n        err.message = \"Internal Server Error\";\n    }\n    res.status(err.statusCode).json({\n        errorMessage: err.message,\n    });\n});\n</code></pre>","tags":["Praxis"]},{"location":"Praxis/JsonWebToken.html","title":"JSON Web Token (JWT)","text":"<p>JSON Web Tokens (JWT) werden zur Authentifizierung und Autorisierung in Webanwendungen verwendet. Sie enthalten verschl\u00fcsselte Informationen, die verwendet werden k\u00f6nnen, um Benutzer zu verifizieren und Zugriffskontrollen durchzuf\u00fchren. <sup>1</sup></p> Erstellen eines JWT<pre><code>const jwt = require(\"jsonwebtoken\");\nconst secretKey = \"yourSecretKey\";\nconst token = jwt.sign({ data: \"payloadData\" }, secretKey, { expiresIn: \"1h\" });\nconsole.log(token);\n</code></pre> Verifizieren eines JWT<pre><code>const decoded = jwt.verify(token, secretKey);\nconsole.log(decoded);\n</code></pre>","tags":["Praxis"]},{"location":"Praxis/JsonWebToken.html#router-middleware","title":"Router Middleware","text":"<p>Um die Authentifizierung und Autorisierung in Express.js zu implementieren, k\u00f6nnen Sie Middleware verwenden, um den JWT aus dem HTTP-Header zu extrahieren und zu verifizieren.</p> Middleware in Router einbinden (api.js)<pre><code>api.use(extractApiKey);\napi.use(routes);\n</code></pre> Middleware in Router einbinden (routes.js)<pre><code>router.get(\n    \"/users/:userid/mnts\",\n    isOwner,\n    isAdmin,\n    requireAuth,\n    mountainCtrl.getAllUserMountainIds\n);\n</code></pre> Auslesen des Tokens aus dem Header<pre><code>module.exports = (req, res, next) =&gt; {\n    let isValid = false;\n\n    try {\n        // Ist der Value des Feldes Authorization des HTTP-Headers \u00fcberhaupt vorhanden?\n        const authHeader = req.get(\"Authorization\");\n        if (authHeader) {\n            // \u00dcberpr\u00fcfen, ob der Wert des Feldes Authorization mit dem String \"Bearer \" beginnt.\n            if (authHeader.startsWith(TOKEN_PREFIX)) {\n                // Den Bearer-String entfernen.\n                const jwtToken = authHeader.substring(TOKEN_PREFIX.length);\n                if (jwtToken) {\n                    // Verifizieren Sie das Token mit der Methode verify().\n                    const decodedToken = token.verify(jwtToken, JWTSECTRET);\n                    if (decodedToken) {\n                        res.locals.authorization = decodedToken;\n                        isValid = true;\n                    }\n                }\n            }\n        }\n    } catch (err) {\n        logger.info(err.message, {\n            errno: err.errno,\n            error: err,\n        });\n    }\n\n    res.locals.isAuthorized = isValid;\n    next();\n};\n</code></pre> \u00dcberpr\u00fcfen der Autorisierung<pre><code>const {\n    HTTP_STATUS_UNAUTHORIZED,\n    HTTP_STATUS_FORBIDDEN,\n} = require(\"../util/const\");\n\nmodule.exports = (req, res, next) =&gt; {\n    if (!res.locals?.isAuthorized) {\n        if (res.locals?.authorization) {\n            const error = new Error(\"Forbidden access\");\n            error.statusCode = HTTP_STATUS_FORBIDDEN;\n            throw error;\n        }\n\n        const error = new Error(\"Unauthorized access\");\n        error.statusCode = HTTP_STATUS_UNAUTHORIZED;\n        throw error;\n    }\n    next();\n};\n</code></pre> Admin-Rolle \u00fcberpr\u00fcfen<pre><code>module.exports = (req, res, next) =&gt; {\n    res.locals.isAuthorized = res.locals?.authorization?.data?.isadmin ?? false;\n    next();\n};\n</code></pre> Benutzer-Rolle \u00fcberpr\u00fcfen<pre><code>module.exports = (req, res, next) =&gt; {\n    res.locals.isAuthorized =\n        req.params.userId &amp;&amp;\n        req.params.userId === res.locals?.authorization?.sub;\n    next();\n};\n</code></pre> <ol> <li> <p>Weitere Informationen: https://docs.google.com/document/d/1tuvMAmY7vvALhTaqmyBRIFDrZ7gI31Uxpoxa-RqUrDI/edit#heading=h.5cqlsyp3uxym \u21a9</p> </li> </ol>","tags":["Praxis"]},{"location":"Praxis/Logging.html","title":"Logging","text":"<p>Logging ist essenziell f\u00fcr die \u00dcberwachung und Fehlerdiagnose in Anwendungen. Die Bibliothek <code>winston</code> ist ein leistungsf\u00e4higes Logging-Tool in Node.js.</p> Initialisierung des Loggers<pre><code>const winston = require(\"winston\");\nconst logger = winston.createLogger({\n    level: \"info\",\n    format: winston.format.json(),\n    transports: [\n        new winston.transports.File({ filename: \"error.log\", level: \"error\" }),\n        new winston.transports.File({ filename: \"combined.log\" }),\n    ],\n});\n</code></pre> Logging von Informationen<pre><code>logger.info(\"This is an informational message\");\n</code></pre> Logging von Fehlern<pre><code>logger.error(\"This is an error message\");\n</code></pre> Logging von Fehlern mit Metadaten<pre><code>try {\n    throw new Error(\"This is an error message\");\n} catch (err) {\n    logger.error(err.message, {\n        errno: err.errno,\n        error: err,\n    });\n}\n</code></pre> Logging von Fehlern in Express<pre><code>app.use((err, req, res, next) =&gt; {\n    logger.error(err.message, {\n        errno: err.errno,\n        error: err,\n    });\n    res.status(err.statusCode || 500).json({ errorMessage: err.message });\n});\n</code></pre>","tags":["Praxis"]},{"location":"Praxis/PasswortHashing.html","title":"Passwort Hashing","text":"<p>Passwort-Hashing ist eine grundlegende Sicherheitsma\u00dfnahme, um sensible Informationen wie Passw\u00f6rter zu sch\u00fctzen. Anstatt Passw\u00f6rter im Klartext zu speichern, werden diese mithilfe von Hashing-Algorithmen in eine nicht umkehrbare Form umgewandelt. Die Bibliothek <code>bcrypt</code> ist in Node.js weit verbreitet, um Passw\u00f6rter zu hashen und zu verifizieren. <sup>1</sup></p> Installation von bcrypt<pre><code>npm install bcrypt\n</code></pre> Hashing eines Passworts<pre><code>const bcrypt = require(\"bcrypt\");\nconst saltRounds = 10;\nconst plainPassword = \"yourPassword\";\n\nconst hashedPassword = bcrypt.hashSync(plainPassword, saltRounds);\nconsole.log(hashedPassword);\n</code></pre> Verifizieren eines Passworts<pre><code>const isMatch = bcrypt.compareSync(plainPassword, hashedPassword);\nconsole.log(isMatch); // true oder false\n</code></pre> <ol> <li> <p>bcrypt: https://github.com/kelektiv/node.bcrypt.js#sync \u21a9</p> </li> </ol>","tags":["Praxis"]},{"location":"Praxis/Validierung.html","title":"User-Input-Validierung","text":"<p>Die Validierung von Benutzereingaben verhindert, dass sch\u00e4dliche oder ung\u00fcltige Daten in die Anwendung gelangen. Die Bibliothek <code>validator</code> bietet viele Funktionen zur Validierung und Sanitierung von Eingaben. <sup>1</sup></p> Installation von validator<pre><code>npm install validator\n</code></pre> Validierung von E-Mail-Adressen<pre><code>const validator = require(\"validator\");\nconst isValidEmail = validator.isEmail(\"test@example.com\");\nconsole.log(isValidEmail); // true oder false\n</code></pre> Validierung von Benutzereingaben in Vue.js<pre><code>&lt;template&gt;\n    &lt;v-card class=\"d-flex flex-column\"&gt;\n        &lt;form @submit=\"onSubmit\"&gt;\n            &lt;v-card-title&gt;Neuen Berg erfassen:&lt;/v-card-title&gt;\n            &lt;v-card-text&gt;\n                &lt;v-text-field\n                    v-model=\"mntName.value.value\"\n                    label=\"Name\"\n                    :error-messages=\"errors.mntName\"\n                    dense\n                    clearable&gt;&lt;/v-text-field&gt;\n                &lt;v-text-field\n                    v-model=\"mntDescription.value.value\"\n                    label=\"Description\"\n                    :error-messages=\"errors.mntDescription\"\n                    dense\n                    clearable&gt;&lt;/v-text-field&gt;\n                &lt;v-text-field\n                    v-model=\"mntLatitude.value.value\"\n                    label=\"Breitengrad\"\n                    :error-messages=\"errors.mntLatitude\"\n                    dense\n                    clearable&gt;&lt;/v-text-field&gt;\n                &lt;v-text-field\n                    v-model=\"mntLongitude.value.value\"\n                    label=\"L\u00e4ngengrad\"\n                    :error-messages=\"errors.mntLongitude\"\n                    dense\n                    clearable&gt;&lt;/v-text-field&gt;\n                &lt;v-text-field\n                    v-model=\"mntElevation.value.value\"\n                    label=\"H\u00f6he\"\n                    :error-messages=\"errors.mntElevation\"\n                    dense\n                    clearable&gt;&lt;/v-text-field&gt;\n                &lt;v-file-input\n                    v-model=\"file\"\n                    accept=\"image/png image/jpg image/jpeg\"\n                    label=\"Datei\"\n                    dense\n                    clearable&gt;&lt;/v-file-input&gt;\n            &lt;/v-card-text&gt;\n            &lt;v-card-actions class=\"mt-auto d-flex justify-end\" width=\"100\"&gt;\n                &lt;v-btn icon=\"mdi-close\" @click=\"cancel\"&gt; &lt;/v-btn&gt;\n                &lt;v-btn variant=\"tonal\" type=\"submit\" icon=\"mdi-check\"&gt; &lt;/v-btn&gt;\n            &lt;/v-card-actions&gt;\n        &lt;/form&gt;\n    &lt;/v-card&gt;\n&lt;/template&gt;\n</code></pre> Validierung von Benutzereingaben in Vue.js<pre><code>&lt;script&gt;\nimport { ref } from \"vue\";\nimport { useUserStore } from \"../stores/user.js\";\nimport { useErrorStore } from \"../stores/error.js\";\nimport useHelpers from \"../hooks/helpers.js\";\nimport { storeToRefs } from \"pinia\";\nimport { useForm, useField } from \"vee-validate\";\nimport * as yup from \"yup\";\n\nexport default {\n    emits: [\"cancelNewMnt\", \"saveNewMnt\"],\n\n    setup(porps, ctx) {\n        const {\n            jwt,\n            id: userId,\n            isAuthenticated,\n        } = storeToRefs(useUserStore());\n\n        const { alert } = useErrorStore();\n        const { checkHttpStatus } = useHelpers();\n\n        const { handleSubmit, errors } = useForm({\n            validationSchema: yup.object({\n                mntName: yup.string().required(\"Pflichtfeld\"),\n                mntDescription: yup.string().required(\"Pflichtfeld\"),\n                mntLatitude: yup\n                    .number()\n                    .min(-90.0, \"Breitengrad &gt;= -90.0\u00b0\")\n                    .max(90.0, \"Breitengrad &lt;= 90.0\u00b0\")\n                    .required(\"Pflichtfeld\")\n                    .typeError(\"Breitengrad muss eine Zahl sein\"),\n                mntLongitude: yup\n                    .number()\n                    .min(-180.0, \"L\u00e4ngengrad &gt;= -180.0\u00b0\")\n                    .max(180.0, \"L\u00e4ngengrad &gt;= 180.0\u00b0\")\n                    .required(\"Pflichtfeld\")\n                    .typeError(\"L\u00e4ngengrad muss eine Zahl sein\"),\n                mntElevation: yup\n                    .number()\n                    .integer(\"H\u00f6he muss eine ganze Zahl sein\")\n                    .required(\"Pflichtfeld\")\n                    .typeError(\"H\u00f6he muss eine ganze Zahl sein\"),\n            }),\n        });\n\n        const mntName = useField(\"mntName\");\n        const mntDescription = useField(\"mntDescription\");\n        const mntLatitude = useField(\"mntLatitude\");\n        const mntLongitude = useField(\"mntLongitude\");\n        const mntElevation = useField(\"mntElevation\");\n        const file = ref([]);\n\n        const onSubmit = handleSubmit((values) =&gt; {\n            save();\n        });\n\n        function cancel() {\n            ctx.emit(\"cancelNewMnt\");\n        }\n\n        async function save() {\n            try {\n                let res;\n                // step 1: create new mountain object at backend (without image)\n                let reqBody = JSON.stringify({\n                    name: mntName.value.value,\n                    description: mntDescription.value.value,\n                    elevation: mntElevation.value.value,\n                    latitude: mntLatitude.value.value,\n                    longitude: mntLongitude.value.value,\n                    hasmountainrailway: false,\n                });\n                let postReqHeaders = { \"Content-Type\": \"application/json\" };\n                let putReqHeaders = {};\n\n                // add JWT to request header, if user-specific mountain should be added\n                if (isAuthenticated.value) {\n                    postReqHeaders[\"Authorization\"] = `Bearer ${jwt.value}`;\n                    putReqHeaders[\"Authorization\"] = `Bearer ${jwt.value}`;\n                }\n\n                if (isAuthenticated.value) {\n                    res = await fetch(\n                        `${import.meta.env.VITE_BACKEND}/users/${\n                            userId.value\n                        }/mnts`,\n                        {\n                            method: \"POST\",\n                            headers: postReqHeaders,\n                            body: reqBody,\n                        }\n                    );\n                } else {\n                    res = await fetch(`${import.meta.env.VITE_BACKEND}/mnts`, {\n                        method: \"POST\",\n                        headers: postReqHeaders,\n                        body: reqBody,\n                    });\n                }\n\n                checkHttpStatus(res);\n                let savedMnt = await res.json();\n\n                // step 2: get id of newly created mountain, then upload image\n                const mntId = savedMnt.properties.id;\n                reqBody = new FormData();\n                reqBody.append(\"image\", file.value[0]);\n\n                if (isAuthenticated.value) {\n                    res = await fetch(\n                        `${import.meta.env.VITE_BACKEND}/users/${\n                            userId.value\n                        }/mnts/${mntId}/img`,\n                        {\n                            method: \"PUT\",\n                            body: reqBody,\n                            headers: putReqHeaders,\n                        }\n                    );\n                } else {\n                    res = await fetch(\n                        `${import.meta.env.VITE_BACKEND}/mnts/${mntId}/img`,\n                        {\n                            method: \"PUT\",\n                            body: reqBody,\n                        }\n                    );\n                }\n\n                checkHttpStatus(res);\n                savedMnt = await res.json();\n\n                // step 3: notify parent component (gallery component) of newly added mountain\n                ctx.emit(\"saveNewMnt\", mntId);\n            } catch (err) {\n                alert(err.message, \"error\");\n            }\n        }\n\n        return {\n            mntName,\n            mntDescription,\n            mntLatitude,\n            mntLongitude,\n            mntElevation,\n            file,\n            errors,\n            onSubmit,\n            cancel,\n            save,\n        };\n    },\n};\n&lt;/script&gt;\n</code></pre> <ol> <li> <p>Quelle: https://docs.google.com/document/d/1IjBf3GBy-9k2icUjj_hTiz10LPc9Ad11TqzmXAY0TQE/edit \u21a9</p> </li> </ol>","tags":["Praxis"]},{"location":"Praxis/XSS.html","title":"XSS (Cross-Site Scripting)","text":"<p>Cross-Site Scripting (XSS) ist eine Sicherheitsl\u00fccke, bei der Angreifer b\u00f6sartigen Code in Webseiten einschleusen, um sensible Informationen zu stehlen oder Benutzer zu t\u00e4uschen. XSS-Angriffe k\u00f6nnen in drei Kategorien unterteilt werden: Reflected XSS, Stored XSS und DOM-based XSS. Um XSS-Angriffe zu verhindern, sollten Entwickler Benutzereingaben validieren und sicherstellen, dass sie nicht direkt in HTML eingef\u00fcgt werden. <sup>1</sup></p> <p>XSS-Angriffe erfolgen durch das Einf\u00fcgen von sch\u00e4dlichem Skript in Webanwendungen. <code>dompurify</code> ist ein Werkzeug zur Bereinigung von HTML, um XSS-Angriffe zu verhindern.<sup>2</sup></p> Installation von dompurify<pre><code>npm install dompurify\n</code></pre> Verwendung von dompurify<pre><code>const DOMPurify = require(\"dompurify\");\nconst cleanHTML = DOMPurify.sanitize('&lt;script&gt;alert(\"XSS\")&lt;/script&gt;');\nconsole.log(cleanHTML); // ''\n</code></pre> <ol> <li> <p>Quelle: https://docs.google.com/document/d/1dsY6yo6o5OF7koziCfuGUKM5tguv5fT9va_2R509wG8/edit#heading=h.vxrztom7guhs \u21a9</p> </li> <li> <p>Quelle: https://www.npmjs.com/package/dompurify \u21a9</p> </li> </ol>","tags":["Praxis"]},{"location":"Theorie/OpenSSL.html","title":"OpenSSL","text":"<p>Konsole Zusammenfassung</p> <p>OpenSSL ist eine leistungsstarke Open-Source-Implementierung von SSL (Secure Sockets Layer) und TLS (Transport Layer Security) Protokollen. Es enth\u00e4lt eine Vielzahl von Werkzeugen zum Erzeugen und Verwalten von Schl\u00fcsseln und Zertifikaten. <sup>2</sup></p>","tags":["Theorie"]},{"location":"Theorie/OpenSSL.html#befehle-zur-schlussel-und-zertifikatserzeugung","title":"Befehle zur Schl\u00fcssel- und Zertifikatserzeugung:","text":"<ul> <li>Private Key generieren: <code>openssl genpkey -algorithm RSA -out private_key.pem -aes256</code></li> <li>\u00d6ffentlichen Schl\u00fcssel extrahieren: <code>openssl rsa -pubout -in private_key.pem -out public_key.pem</code></li> <li>Zertifikatsignierungsanforderung (CSR) erstellen: <code>openssl req -new -key private_key.pem -out request.csr</code></li> <li>Selbstsigniertes Zertifikat erstellen: <code>openssl req -x509 -key private_key.pem -in request.csr -out certificate.pem -days 365</code></li> </ul> Weitere Befehle f\u00fcr OpenSSL <p>Schl\u00fcsselgenerierung</p> Generieren eines RSA-Privatschl\u00fcssels:<pre><code>openssl genpkey -algorithm RSA -out private_key.pem -aes256\n</code></pre> <ul> <li><code>-aes256</code>: Verschl\u00fcsselt den privaten Schl\u00fcssel mit AES-256.</li> </ul> Generieren eines RSA-Privatschl\u00fcssels mit spezifischer Schl\u00fcssell\u00e4nge:<pre><code>openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:4096\n</code></pre> <ul> <li><code>-pkeyopt rsa_keygen_bits:4096</code>: Setzt die Schl\u00fcssell\u00e4nge auf 4096 Bits.</li> </ul> <p>Zertifikate</p> Erstellen einer Zertifikatsignierungsanforderung (CSR):<pre><code>openssl req -new -key private_key.pem -out request.csr\n</code></pre> Erstellen eines selbstsignierten Zertifikats:<pre><code>openssl req -x509 -key private_key.pem -in request.csr -out certificate.pem -days 365\n</code></pre> <p>Verschl\u00fcsselung und Entschl\u00fcsselung</p> Verschl\u00fcsseln einer Datei:<pre><code>openssl enc -aes-256-cbc -salt -in plaintext.txt -out encrypted.txt\n</code></pre> Entschl\u00fcsseln einer Datei:<pre><code>openssl enc -aes-256-cbc -d -in encrypted.txt -out decrypted.txt\n</code></pre> <p>Hashing</p> Berechnen des SHA256-Hashes einer Datei:<pre><code>openssl dgst -sha256 file.txt\n</code></pre> <p>OpenSSL-Befehlsoptionen</p> <p>Hier sind einige allgemeine Optionen, die h\u00e4ufig verwendet werden:</p> <ul> <li><code>-in</code>: Gibt die Eingabedatei an.</li> <li><code>-out</code>: Gibt die Ausgabedatei an.</li> <li><code>-aes256</code>, <code>-aes-128-cbc</code>, <code>-des3</code>: Gibt den Verschl\u00fcsselungsalgorithmus an.</li> <li><code>-salt</code>: F\u00fcgt Salz zu einer Verschl\u00fcsselung hinzu, um die Sicherheit zu erh\u00f6hen.</li> <li><code>-d</code>: Dekodiert oder entschl\u00fcsselt Daten.</li> </ul>","tags":["Theorie"]},{"location":"Theorie/OpenSSL.html#primzahlen","title":"Primzahlen","text":"<p>Primzahlen sind nat\u00fcrliche Zahlen gr\u00f6\u00dfer als 1, die nur durch 1 und sich selbst teilbar sind. Sie spielen eine zentrale Rolle in der Kryptographie, insbesondere bei der Generierung von Schl\u00fcsselpaaren f\u00fcr Algorithmen wie RSA.</p>","tags":["Theorie"]},{"location":"Theorie/OpenSSL.html#befehle-zur-primzahlgenerierung-mit-openssl","title":"Befehle zur Primzahlgenerierung mit OpenSSL:","text":"<ul> <li>Primzahl generieren: <code>openssl prime -generate -bits 2048</code><ul> <li>Dieser Befehl erzeugt eine 2048-Bit-Primzahl.</li> </ul> </li> <li>Testen, ob eine Zahl prim ist: <code>openssl prime -hex 0xD3A8D3B1</code><ul> <li>Dieser Befehl \u00fcberpr\u00fcft, ob die angegebene hexadezimale Zahl eine Primzahl ist.</li> </ul> </li> </ul> Weitere Befehle f\u00fcr Primzahlen <p>Generieren von Primzahlen</p> Generiere eine Primzahl mit einer bestimmten L\u00e4nge in Bits:<pre><code>openssl prime -generate -bits 2048\n</code></pre> Generiere eine Primzahl mit zus\u00e4tzlichen Optionen:<pre><code>openssl prime -generate -bits 2048 -hex -safe\n</code></pre> <ul> <li><code>hex</code>: Gibt die Primzahl im hexadezimalen Format aus.</li> <li><code>safe</code>: Generiert eine \"sichere\" Primzahl, d.h. \ud835\udc5d p ist prim und ( \ud835\udc5d \u2212 1 ) / 2 (p\u22121)/2 ist ebenfalls prim.</li> </ul> <p>Testen von Zahlen auf Primzahl-Eigenschaft</p> Testen, ob eine Zahl prim ist:<pre><code>openssl prime 1234567891\n</code></pre> Testen einer hexadezimalen Zahl:<pre><code>openssl prime -hex 0xD3A8D3B1\n</code></pre>","tags":["Theorie"]},{"location":"Theorie/OpenSSL.html#rsa-verschlusselung","title":"RSA-Verschl\u00fcsselung","text":"<p>RSA das verbreitetste asymmetrische Verschl\u00fcsselungsverfahren (public-key cryptography). Es bildet die Grundlage f\u00fcr die Gew\u00e4hrleistung der Vertraulichkeit und Integrit\u00e4t von digitalen Daten. Die Entwicklung geht zur\u00fcck in die 70er-Jahre auf die drei Mathematiker Ronald R ivest, Adi S hamir und Leonard A dleman.<sup>1</sup></p> <p>RSA bildet zusammen mit ECC (elliptic-curve cryptography) die beiden wichtigsten asymmetrischen Verschl\u00fcsselungsverfahren.</p> <p>RSA (Rivest-Shamir-Adleman) ist ein asymmetrisches Kryptosystem, das weit verbreitet f\u00fcr sichere Daten\u00fcbertragung eingesetzt wird. Es basiert auf der mathematischen Schwierigkeit, gro\u00dfe Primzahlen zu faktorisieren.</p> <ul> <li>Schl\u00fcsselgenerierung: Zwei gro\u00dfe Primzahlen (<code>p</code>) und (<code>q</code>) werden gew\u00e4hlt. Das Produkt (<code>n = p * q</code>) bildet den Modul. Der \u00f6ffentliche Schl\u00fcssel besteht aus (<code>n</code>) und einem Exponenten (<code>e</code>) (typischerweise 65537), w\u00e4hrend der private Schl\u00fcssel aus (<code>n</code>) und einem Exponenten (<code>d</code>) besteht, der die Umkehrung von (<code>e</code>) modulo (<code>(p-1)*(q-1)</code>) ist.</li> <li>Verschl\u00fcsselung: Eine Nachricht (<code>m</code>) wird mit dem \u00f6ffentlichen Schl\u00fcssel verschl\u00fcsselt: <code>c = m^e mod n</code>.</li> <li>Entschl\u00fcsselung: Der verschl\u00fcsselte Text (<code>c</code>) wird mit dem privaten Schl\u00fcssel entschl\u00fcsselt: <code>m = c^d mod n</code>.</li> </ul>","tags":["Theorie"]},{"location":"Theorie/OpenSSL.html#kongruenz-bedeutung","title":"Kongruenz - Bedeutung","text":"<p>Zwei nat\u00fcrliche Zahlen a und b sind zueinander kongruent, wenn diese bei der Division durch eine nat\u00fcrliche Zahl N den gleichen Rest (remainder) liefern. Man sagt dann \"a und b sind kongruent modulo n\" oder \"a und b sind kongruent nach dem Modulus n\". Die formale Schreibweise dazu:</p> <pre><code>a = b (mod n) oder a =n b\n</code></pre>","tags":["Theorie"]},{"location":"Theorie/OpenSSL.html#kongruenz-in-rsa","title":"Kongruenz in RSA","text":"<p>Kongruenz mit der dahinterliegenden Zahlentheorie ist der grundlegende Baustein des RSA-Verfahrens. Nachrichten werden normalerweise als Strings angesehen, die ver- und entschl\u00fcsselt werden. Jeder String ist aber letztendlich eine Folge von Bits, eine solche Folge von Bits kann aber ebenso gut als Integer bzw, nat\u00fcrliche Zahl interpretiert werden. Es besteht also prinzipiell eine eineindeutige (sogenannte bijektive) Beziehung zwischen einem String und einem Integer. RSA wendet ausschliesslich Integer-Operationen an. Eine Nachricht wird in RSA als Integer/nat\u00fcrliche Zahl repr\u00e4sentiert.</p> Symbol Bedeutung m unverschl\u00fcsselter Wert c verschl\u00fcsselter Wert n Modulus. Entspricht zusammen mit e den \u00f6ffentlichen Schl\u00fcssel. e Exponent f\u00fcr Verschl\u00fcsselung (encrypt). Entspricht (zusammen mit dem Modulus n) dem \u00f6ffentlichen Schl\u00fcssel (public key). d Exponent f\u00fcr Entschl\u00fcsselung (decrypt). Entspricht dem privaten Schl\u00fcssel (private key).","tags":["Theorie"]},{"location":"Theorie/OpenSSL.html#wahl-von-n-e-und-d","title":"Wahl von n, e und d","text":"<p>F\u00fcr die Wahl von n, e und d gibt es zahlentheoretische Grundlagen, die auf das 17. und 18. Jahrhundert zur\u00fcckgehen, zum Beispiel</p> <ul> <li> Kleiner fermatsche Satz</li> <li>Satz von Euler (Verallgemeinerung des kleinen fermatschen Satzes)</li> </ul>","tags":["Theorie"]},{"location":"Theorie/OpenSSL.html#n-modulus","title":"n (Modulus)","text":"<p>Im Unterschied zum obigen Beispiel sind die effektiv verwendeten Zahlen um Dimensionen gr\u00f6sser. Der Modulus n hat in RSA typischerweise eine L\u00e4nge von 2048 oder gar 4096 Bits. Diese entspricht einer nat\u00fcrlichen Zahlen mit etwa 600 bis 1200 Stellen. Der gew\u00e4hlte Modulus n hat eine fundamentale Eigenschaft, die RSA letztendlich eine hohe Sicherheit verleiht: n ist das Produkt zweier sehr grossen Primzahlen (bis zu einige hundert Stellen lang) p und q</p> <pre><code>n = p * q\n</code></pre>","tags":["Theorie"]},{"location":"Theorie/OpenSSL.html#e-public-key","title":"e (public key)","text":"<p>e (bildet zusammen mit n den public key) wird prinzipiell auch aus n abgeleitet. Heutzutage wird meistens der universelle Wert 65637 gew\u00e4hlt.</p>","tags":["Theorie"]},{"location":"Theorie/OpenSSL.html#d-private-key","title":"d (private key)","text":"<p>d (private key) wird aus e sowie p und q abgeleitet. Vor allem aber: Es gibt bis heute keine Algorithmen, die den Modulus n in vern\u00fcnftiger Zeit in die beiden Primfaktoren p und q zerlegen k\u00f6nnten. Dies ist aber Voraussetzung, um diesen geheimen Schl\u00fcssel berechnen zu k\u00f6nnen. p und q werden nur bei der Erzeugung von n und d ben\u00f6tigt, danach werden diese beiden Primzahlen nicht mehr gebraucht und weggeworfen. Das macht die St\u00e4rke des RSA-Verfahrens aus.</p> <p>Die Primfaktorzerlegung als \"pi\u00e8ce de r\u00e9sistance\" des Verfahrens steht im Kontrast zur Tatsache, dass eine grosse Zahl \u00e4usserst effizient auf prim getestet werden kann. Grosse Primzahlen k\u00f6nnen mit den heutigen Algorithmen einfach gefunden werden, was letztendlich die Grundlage zur Verbreitung von RSA beitrug.</p> Operationen mit sehr grossen nat\u00fcrlichen Zahlen Laufzeit Test auf Primzahl schnell Finden einer Primzahl schnell Division, Berechnung Restbetrag (mod) schnell Multiplikation, Potenzen schnell Primfaktorzerlegung sehr langsam <ol> <li> <p>Weitere Informationen: https://www.golinuxcloud.com/openssl-cheatsheet/ \u21a9</p> </li> <li> <p>Quelle: https://docs.google.com/document/d/143kpSF6D4UGF13yX7ubqC5HKnQnFIb2sBTf7_x4V3Uo/edit \u21a9</p> </li> </ol>","tags":["Theorie"]},{"location":"Theorie/Sicherheitsluecken.html","title":"Sicherheitsl\u00fccken","text":"<p>Sicherheitsl\u00fccken sind Schwachstellen in einer Software, die es Angreifern erm\u00f6glichen, unerlaubten Zugriff auf Systeme oder Daten zu erhalten. Die folgenden Sicherheitsl\u00fccken sind besonders relevant f\u00fcr Webanwendungen<sup>1</sup>:</p>","tags":["Theorie"]},{"location":"Theorie/Sicherheitsluecken.html#sql-injection","title":"SQL-Injection","text":"<p>SQL-Injection ist eine Technik, bei der Angreifer sch\u00e4dlichen SQL-Code in eine Abfrage einf\u00fcgen, um auf die Datenbank zuzugreifen oder sie zu manipulieren.</p> <ul> <li>ORM (Object-Relational Mapping): ORMs abstrahieren die Datenbankinteraktionen und k\u00f6nnen helfen, SQL-Injections zu vermeiden, indem sie vorbereitete Anweisungen und Parameterbindungen verwenden.</li> </ul>","tags":["Theorie"]},{"location":"Theorie/Sicherheitsluecken.html#command-injection","title":"Command-Injection","text":"<p>Bei einer Command-Injection kann ein Angreifer beliebige Betriebssystembefehle auf einem Server ausf\u00fchren. Dies geschieht oft durch unsichere Handhabung von Benutzereingaben.</p>","tags":["Theorie"]},{"location":"Theorie/Sicherheitsluecken.html#cross-site-scripting-xss","title":"Cross-Site Scripting (XSS)","text":"<p>XSS erm\u00f6glicht es Angreifern, sch\u00e4dliches JavaScript in Webseiten einzubetten, das im Browser anderer Benutzer ausgef\u00fchrt wird.</p> <ul> <li>Typen:<ul> <li>Reflected XSS: Der sch\u00e4dliche Code wird im HTTP-Request \u00fcbergeben und sofort im Response ausgef\u00fchrt.</li> <li>Stored XSS: Der sch\u00e4dliche Code wird in der Datenbank gespeichert und bei sp\u00e4teren Anfragen ausgef\u00fchrt.</li> <li>DOM-based XSS: Der Angriff erfolgt durch Manipulation der clientseitigen Scripts.</li> </ul> </li> </ul>","tags":["Theorie"]},{"location":"Theorie/Sicherheitsluecken.html#business-logic-vulnerabilities","title":"Business Logic Vulnerabilities","text":"<p>Diese Schwachstellen entstehen durch Fehler in der Gesch\u00e4ftslogik einer Anwendung, die es Angreifern erm\u00f6glichen, unerwartete oder unberechtigte Aktionen durchzuf\u00fchren.</p>","tags":["Theorie"]},{"location":"Theorie/Sicherheitsluecken.html#csrf-cross-site-request-forgery","title":"CSRF (Cross-Site Request Forgery)","text":"<p>CSRF zwingt einen angemeldeten Benutzer dazu, unerw\u00fcnschte Aktionen in einer Webanwendung durchzuf\u00fchren. Ein Angreifer nutzt die Authentifizierung des Benutzers aus, um sch\u00e4dliche Aktionen durchzuf\u00fchren.</p>","tags":["Theorie"]},{"location":"Theorie/Sicherheitsluecken.html#cors-cross-origin-resource-sharing","title":"CORS (Cross-Origin Resource Sharing)","text":"<p>CORS ist ein Mechanismus, der den Zugriff auf Ressourcen von einer anderen Domain kontrolliert. Unsachgem\u00e4\u00dfe CORS-Konfigurationen k\u00f6nnen zu Sicherheitsl\u00fccken f\u00fchren.</p>","tags":["Theorie"]},{"location":"Theorie/Sicherheitsluecken.html#cookies-sessions-sop-und-preflight","title":"Cookies, Sessions, SOP und Preflight","text":"<ul> <li>Cookies: Werden zur Sitzungsverwaltung verwendet und sollten sicher konfiguriert sein (z.B. HttpOnly, Secure).</li> <li>Sessions: Verwalten Benutzersitzungen und sollten sicher gegen Session-Hijacking und Fixation sein.</li> <li>SOP (Same-Origin Policy): Beschr\u00e4nkt, wie Dokumente oder Skripte von verschiedenen Urspr\u00fcngen miteinander interagieren k\u00f6nnen.</li> <li>Preflight: Eine CORS-Option, bei der der Browser eine OPTIONS-Anfrage sendet, bevor die eigentliche Anfrage gestellt wird, um zu \u00fcberpr\u00fcfen, ob die Anfrage zul\u00e4ssig ist.</li> </ul> <ol> <li> <p>Quelle: https://docs.google.com/document/d/1YztvowA9ToM_Jxmxt7pTjOTjr2e0POOdwdMa66Uc4O4/edit#heading=h.m0jl6t12cyvk \u21a9</p> </li> <li> <p>Quelle: https://portswigger.net/web-security/cross-site-scripting#what-is-cross-site-scripting-xss \u21a9</p> </li> </ol>","tags":["Theorie"]},{"location":"Theorie/Sicherheitsprinzipien.html","title":"Grundlegende Sicherheitsprinzipien","text":"<p>Die grundlegenden Sicherheitsprinzipien sind in vier Kategorien unterteilt, welche die Sicherheit von Informationen gew\u00e4hrleisten sollen. <sup>1</sup></p> Kategorie Prinzipien Vertraulichkeit Information vor unberechtigten Dritten verschlossen Integrit\u00e4t Information nicht durch Dritte abge\u00e4ndert Verf\u00fcgbarkeit Information bleibt verf\u00fcgbar Nicht-Abstreitbarkeit Information kann nicht abgestritten werden","tags":["Theorie"]},{"location":"Theorie/Sicherheitsprinzipien.html#vertraulichkeit-confidentiality","title":"Vertraulichkeit (confidentiality)","text":"<p>Sicherstellung, dass eine Information vor unberechtigten Dritten verschlossen bleibt.</p>","tags":["Theorie"]},{"location":"Theorie/Sicherheitsprinzipien.html#integritat-integrity","title":"Integrit\u00e4t (integrity)","text":"<p>Sicherstellung, dass eine Information authentisch bleibt. Dazu geh\u00f6rt, dass kein falsche Identit\u00e4t vorget\u00e4uscht werden kann, dass keine Information durch unberechtigte Dritte (unbemerkt) abge\u00e4ndert werden kann.</p>","tags":["Theorie"]},{"location":"Theorie/Sicherheitsprinzipien.html#verfugbarkeit-availability","title":"Verf\u00fcgbarkeit (availability)","text":"<p>Sicherstellung, dass eine Information verf\u00fcgbar bleibt.</p>","tags":["Theorie"]},{"location":"Theorie/Sicherheitsprinzipien.html#nicht-abstreitbarkeit-unleugbarkeit-non-repudiation","title":"Nicht-Abstreitbarkeit / Unleugbarkeit (non-repudiation)","text":"<p>Sicherstellung, dass das Versenden oder der Empfang einer Information nicht abgestreitet werden kann. Dies ist von Bedeutung bei Informationen, die Teil einer vertraglichen Transaktion sind (zum Beispiel Versenden einer Bestellung oder der Empfang einer Rechnung).</p>","tags":["Theorie"]},{"location":"Theorie/Sicherheitsprinzipien.html#information-disclosure","title":"Information Disclosure","text":"<p>Die Offenlegung von Informationen, auch bekannt als Informationsleck, liegt vor, wenn eine Website unbeabsichtigt sensible Informationen an ihre Nutzer weitergibt. Je nach Kontext k\u00f6nnen Websites alle Arten von Informationen an einen potenziellen Angreifer weitergeben, darunter: <sup>2</sup></p> <ul> <li>Daten \u00fcber andere Nutzer, wie z. B. Benutzernamen oder finanzielle Informationen</li> <li>Sensible kommerzielle oder gesch\u00e4ftliche Daten</li> <li>Technische Details \u00fcber die Website und ihre Infrastruktur</li> </ul> <p>Die Gefahren, die mit der Weitergabe sensibler Benutzer- oder Gesch\u00e4ftsdaten verbunden sind, liegen auf der Hand, aber die Offenlegung technischer Informationen kann manchmal ebenso schwerwiegend sein. Auch wenn einige dieser Informationen nur von begrenztem Nutzen sind, k\u00f6nnen sie ein Ausgangspunkt f\u00fcr die Aufdeckung einer zus\u00e4tzlichen Angriffsfl\u00e4che sein, die weitere interessante Schwachstellen enthalten kann. Das Wissen, das Sie sammeln k\u00f6nnen, k\u00f6nnte sogar das fehlende Puzzlest\u00fcck liefern, wenn Sie versuchen, komplexe, hochgradig gef\u00e4hrliche Angriffe zu konstruieren.</p> <p>Gelegentlich kann es vorkommen, dass sensible Informationen unvorsichtigerweise an Benutzer weitergegeben werden, die ganz normal auf der Website surfen. In den meisten F\u00e4llen muss ein Angreifer jedoch die Offenlegung von Informationen durch unerwartete oder b\u00f6swillige Interaktion mit der Website herbeif\u00fchren. Er wird dann die Antworten der Website sorgf\u00e4ltig studieren, um ein interessantes Verhalten zu erkennen.</p>","tags":["Theorie"]},{"location":"Theorie/Sicherheitsprinzipien.html#beispiele-fur-die-offenlegung-von-informationen","title":"Beispiele f\u00fcr die Offenlegung von Informationen","text":"<p>Nachfolgend einige grundlegende Beispiele f\u00fcr die Offenlegung von Informationen:</p> <ul> <li>Offenlegung der Namen von versteckten Verzeichnissen, ihrer Struktur und ihres Inhalts \u00fcber eine robots.txt-Datei oder eine Verzeichnisliste</li> <li>Zugang zu Quellcodedateien \u00fcber tempor\u00e4re Backups gew\u00e4hren</li> <li>Explizite Nennung von Datenbanktabellen oder Spaltennamen in Fehlermeldungen</li> <li>Unn\u00f6tige Offenlegung hochsensibler Informationen, wie z. B. Kreditkartendaten</li> <li>Festcodierung von API-Schl\u00fcsseln, IP-Adressen, Datenbankanmeldeinformationen usw. im Quellcode</li> <li>Andeutungen \u00fcber das Vorhandensein oder Fehlen von Ressourcen, Benutzernamen usw. durch subtile Unterschiede im Anwendungsverhalten</li> </ul> <ol> <li> <p>Quelle: https://docs.google.com/document/d/160llHSFAyvL57Q0sbU5uby6Ng3A7288zjm2EbemgH3o/edit#heading=h.jcfs1mt5gphx \u21a9</p> </li> <li> <p>Quelle: https://portswigger.net/web-security/information-disclosure \u21a9</p> </li> </ol>","tags":["Theorie"]},{"location":"Theorie/Verschluesselung.html","title":"Verschl\u00fcsselung","text":"<p>Dieses Dokument behandelt Vertraulichkeit und Integrit\u00e4t in der Informationsverarbeitung. <sup>1</sup></p>","tags":["Theorie"]},{"location":"Theorie/Verschluesselung.html#symmetrische-verschlusselung","title":"Symmetrische Verschl\u00fcsselung","text":"<p>Bei symmetrischen Verschl\u00fcsselungsverfahren erfolgt die Ver- und Entschl\u00fcsselung mit dem selben Schl\u00fcssel. <sup>2</sup></p> <p>Vorteile:</p> <ul> <li>Schnell</li> <li>Einfach zu implementieren</li> <li>Beim vergr\u00f6ssern des Schl\u00fcssels wird die Verschl\u00fcsselung sicherer</li> </ul> <p>Nachteile:</p> <ul> <li>Schl\u00fcssel muss vorher ausgetauscht werden</li> <li>Jeder, der den Schl\u00fcssel kennt, kann die Nachricht entschl\u00fcsseln<ul> <li>F\u00fcr jeden Empf\u00e4nger muss ein neuer Schl\u00fcssel generiert werden</li> </ul> </li> </ul>","tags":["Theorie"]},{"location":"Theorie/Verschluesselung.html#asymmetrische-verschlusselung","title":"Asymmetrische Verschl\u00fcsselung","text":"<p>Bei der asymmetrischen Verschl\u00fcsselung kommt ein Schl\u00fcsselpaar zum Einsatz. Nachrichten, die mit dem einen Schl\u00fcssel verschl\u00fcsselt werden, k\u00f6nnen nur mit dem anderen Schl\u00fcssel entschl\u00fcsselt werden. Bei diesem Verfahren wird ein Schl\u00fcssel immer geheim gehalten (geheimer Schl\u00fcssel, private key, secret key), der andere ist \u00f6ffentlich (\u00f6ffentlicher Schl\u00fcssel, public key). <sup>3</sup></p> <p>Vorteile</p> <ul> <li>Kein Schl\u00fcsselaustausch n\u00f6tig</li> <li>Authentifizierung von digitalen Signaturen</li> <li>\u00d6ffentlicher Schl\u00fcssel kann von mehreren Personen verwendet werden</li> </ul> <p>Nachteile</p> <ul> <li>Langsam</li> <li>Sicherheit basiert auf der Annahme, dass der Algorithmus sicher ist</li> </ul>","tags":["Theorie"]},{"location":"Theorie/Verschluesselung.html#hashing","title":"Hashing","text":"<p>Hashing ist ein Verfahren, bei dem eine Eingabe in eine Zeichenkette mit einer festen L\u00e4nge von Buchstaben und Nummern umgewandelt wird. Der daraus resultierende Hashwert ist einzigartig und kann nicht zur\u00fcck in die urspr\u00fcngliche Eingabe umgewandelt werden. <sup>4</sup></p> <p>Dieses Verfahren hat folgende wichtige Eigenschaften:</p> <ul> <li>Ein unver\u00e4nderte Nachricht M berechnet immer den selben Wert H, eine ver\u00e4nderte Nachricht \u2206M berechnet einen ganz anderen Wert H.</li> <li>Der Aufwand, um aus einer Nachricht M den Wert H zu berechnen, ist sehr gering.</li> <li>Der Aufwand, aus dem Wert H die urspr\u00fcngliche Nachricht M zu berechnen, ist \u00e4usserst hoch bzw praktisch unm\u00f6glich.</li> <li>Die Wahrscheinlichkeit, dass zwei verschiedene Nachrichten M1 und M2 zum gleichen Wert H f\u00fchren ist \u00e4usserst gering (Kollisionswahrscheinlichkeit). Praktisch f\u00fchren unterschiedliche Nachrichten immer zu unterschiedlichen Hashwerten.</li> <li>Der Hashwert hat immer die gleich L\u00e4nge (zum Beispiel 256 Bits).</li> </ul>","tags":["Theorie"]},{"location":"Theorie/Verschluesselung.html#anwendungsbeispiel","title":"Anwendungsbeispiel","text":"<p>Passw\u00f6rter sollten niemals persistent abgespeichert werden, stattdessen wird der Hashwert eines Passwort abgelegt. Bei einer Authentifizierung wird der Hashwert des vom Benutzer eingegeben Passwortes erzeugt und mit dem abgelegten Hashwert in der Datenbank verglichen. <sup>5</sup></p> <p>Vorteil: Bei einem Diebstahl von Nutzerdaten (Username und Passwort-Hash) kann aus dem Passwort-Hash nicht auf das Passwort geschlossen werden.</p>","tags":["Theorie"]},{"location":"Theorie/Verschluesselung.html#salting","title":"Salting","text":"<p>Beim Salted Hash wird der Nachricht ein zus\u00e4tzlicher (zuf\u00e4lliger) String hinzugef\u00fcgt, dem sogenannten Salt. Damit wird mit extrem hoher Wahrscheinlichkeit sichergestellt, dass gleiche Nachrichten unterschiedliche Hashwerte produzieren. Der Salt muss nicht geheim bleiben, wichtig ist die zuf\u00e4llige Erzeugung. Der f\u00fcr die Erzeugung des Hashes verwendete Salt wird zusammen mit dem Hashwert abgelegt.</p> <p>Mit der Verwendung von Salted-Hashfunktionen werden vorgefertigte Tabellen unbrauchbar. Die einzige M\u00f6glichkeit einen Hashwert zu knacken sind sogenannte Brute-Force oder Dictionary-Angriffe.</p>","tags":["Theorie"]},{"location":"Theorie/Verschluesselung.html#digitales-zertifikat","title":"Digitales Zertifikat","text":"<p>Ein digitales Zertifikat ist eine Beglaubigung eines \u00f6ffentlichen Schl\u00fcssels.</p> <p>Ein digitales Zertifikat ist ein elektronischer Ausweis, mit dem man die vorgegebene Identit\u00e4t \u00fcberpr\u00fcfen kann. Mit einem digitalen Zertifikat kann man pr\u00fcfen, ob der \u00f6ffentliche Schl\u00fcssel der vorgegebenen Identit\u00e4t geh\u00f6rt. In diese Kategorie geh\u00f6ren auch SSL/TLS-Zertifikate.</p> <p>Eine Zertifizierungsstelle (certificate authority / CA) ist eine Organisation, die einen \u00f6ffentlichen Schl\u00fcssel mit einer Identit\u00e4t verkn\u00fcpft und diese Beziehung beglaubigt. Dies geschieht \u00fcber einen Zertifizierungsantrag (certificate signing request / CSR). Die CA pr\u00fcft die Identit\u00e4t und stellt dann das Zertifikat aus.</p> <p>Manchmal wird zwischen Zertifizierungsstellen (certificate authority / CA) und Registrierungsstellen unterschieden. Die Registrierungsstelle (registration authority / RA) ist die Organisation, die eine Identit\u00e4t \u00fcberpr\u00fcft und einen Zertifizierungsantrag genehmigt, w\u00e4hrende Zertifizierungsstelle auf der Basis eines genehmigten Antrages ein Zertifikat ausstellt. Oft handelt es sich aber um dieselben Organisationen (QuoVaids, Godaddy etc.)</p>","tags":["Theorie"]},{"location":"Theorie/Verschluesselung.html#chain-of-trust-zertifikatskette","title":"Chain of Trust - Zertifikatskette","text":"<p>Weltweit gibt es eine Vielzahl von CAs (Certificate Authorities). Im OS oder Browser sind die vertrauensw\u00fcrdigen CAs hinterlegt.</p> <p>Vertrauensw\u00fcrdig heisst in diesem Kontext: Eine anerkannte Organisation, die Identit\u00e4ten nach vorgegebenen Standards pr\u00fcft.</p> <p>Apple-Ger\u00e4te zum Beispiel vertrauen grunds\u00e4tzlich allen Zertifikaten, die von diesen CAs ausgestellt worden sind. Diese aufgelisteten CAs nennt man root certificate authorities oder Stammzertifizierungsstellen. In den meisten F\u00e4llen wird aber eine Zertifikat nicht von Stammzertifizierungsstellen ausgestellt. Vielmehr gibt es darunter liegende intermedi\u00e4re CAs, die zur Stammzertifizierungsstelle eine Vertrauensstellung haben. Solche vertrauensw\u00fcrdige intermedi\u00e4re CAs k\u00f6nnen sich \u00fcber mehrere Hierarchiestufen erstrecken und bilden eine sogenannte chain of trust oder Zertifikatskette. Zertifikatsketten sind im Zertifikat selbst vorhanden und k\u00f6nnen (zum Beispiel von einem Browser) auf G\u00fcltigkeit gepr\u00fcft werden. Ein Zertifikat gilt als g\u00fcltig, wenn alle Zertifikate dieser Zertifikatskette g\u00fcltig sind und das Stammzertifikat von einer Stammzertifizierungsstelle stammt.</p> <p>Zum Beispiel wurde das TLS-Zertifikat f\u00fcr sbb.ch nicht direkt von der Stammzertifizierungsstelle SwissSign Gold CA - G2 ausgestellt, sondern von einer Sub-Zertifizierungsstelle. Diese Zertifikatskette kann angezeigt werden:</p>","tags":["Theorie"]},{"location":"Theorie/Verschluesselung.html#signaturen","title":"Signaturen","text":"<p>Eine Signatur (oder elektronische Unterschrift) ist ein Zusatz zu einer Nachricht oder Datei. Die Signatur beweist, wer der Erzeuger oder Sender einer Nachricht ist, ebenso kann die Signatur auch beweisen, dass eine Nachricht nicht durch Dritte abge\u00e4ndert wurde. Die Signatur ist ein zentrales Element, um die Integrit\u00e4t einer Nachricht zu gew\u00e4hrleisten.</p>","tags":["Theorie"]},{"location":"Theorie/Verschluesselung.html#jtw","title":"JTW","text":"<p>Ein JWT besteht aus drei Abschnitten: einem Header, einer Nutzlast und einer Signatur. Jeder Abschnitt ist eine Base64-kodierte Zeichenfolge, und die Abschnitte werden durch Punkte getrennt. Ein typisches JWT sieht wie folgt aus, wobei die X's f\u00fcr den Header, die Y's f\u00fcr die Payload und die Z's f\u00fcr die Signatur stehen: <sup>6</sup></p> <pre><code>xxxxxx.yyyyyy.zzzzzz\n</code></pre> <p>Ein explizit geschriebenes JWT w\u00fcrde etwa so aussehen:</p> <pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphbmUgRG9lIiwiaWF0IjoxNjk3MjM5MDIyfQ.5CerSPBCrO_3WdiyPjR7HoWBOeXsuq2AcfplJeG7erc\n</code></pre> <p>JWT ist ein offener Standard (RFC 7519) f\u00fcr die sichere \u00dcbertragung von Informationen zwischen Parteien als JSON-Objekt. Diese Informationen k\u00f6nnen \u00fcberpr\u00fcft und vertrauensw\u00fcrdig sein, da sie digital signiert sind.</p> <ul> <li>Struktur: Ein JWT besteht aus drei Teilen: Header, Payload und Signature, die durch Punkte getrennt sind (<code>header.payload.signature</code>).</li> <li>Header: Typ der Token und das verwendete Signaturalgorithmus.</li> <li>Payload: Enth\u00e4lt die Claims (z.B. Benutzerinformationen, Berechtigungen).</li> <li>Signature: Wird mit einem geheimen Schl\u00fcssel oder einem RSA-Schl\u00fcsselpaar erstellt.</li> </ul>","tags":["Theorie"]},{"location":"Theorie/Verschluesselung.html#header","title":"Header","text":"<p>Der Header enth\u00e4lt Informationen \u00fcber das gesamte JWT, wie z. B. den Hauptalgorithmus (<code>alg</code>), der f\u00fcr die Signierung und Verschl\u00fcsselung (required) verwendet wird, den Medientyp des JWT (<code>typ</code>) und seinen Inhaltstyp (<code>cty</code>). Ein entschl\u00fcsselter JWT-Header k\u00f6nnte wie folgt aussehen:</p> <pre><code>{\n    \"alg\": \"HS256\",\n    \"typ\": \"JWT\"\n}\n</code></pre>","tags":["Theorie"]},{"location":"Theorie/Verschluesselung.html#payload","title":"Payload","text":"<p>The payload consists of all of the data that\u2019s being transmitted. This data is optional, and it is added as claims. There are three primary types of claims: registered claims, private claims, and public claims.</p>","tags":["Theorie"]},{"location":"Theorie/Verschluesselung.html#registered-claims","title":"Registered claims","text":"<p>Dabei handelt es sich um optionale, aber vorab festgelegte Anspr\u00fcche, die in der JWT-Spezifikation definiert sind und die Interoperabilit\u00e4t unterst\u00fctzen. Es gibt sieben Arten von registrierten Claims:</p> <ul> <li>Issuer (<code>iss</code>): Die Partei, die das JWT ausgestellt hat.</li> <li>Subject (<code>sub</code>): Das Subjekt des JWT oder die Entit\u00e4t, \u00fcber die dieses JWT Informationen enth\u00e4lt.</li> <li>Audience (<code>aud</code>): Der Empf\u00e4nger des JWT.</li> <li>Expiration time (<code>exp</code>): Der Zeitpunkt, zu dem das JWT abl\u00e4uft.</li> <li>Not before(<code>nbf</code>): Der Zeitpunkt, vor dem das JWT ung\u00fcltig ist.</li> <li>Issued at (<code>iat</code>): Der Zeitpunkt, zu dem das JWT ausgestellt wurde.</li> <li>JTW ID (<code>jti</code>): Eine Zeichenfolge, die als eindeutiger Bezeichner f\u00fcr dieses JWT dient.</li> </ul>","tags":["Theorie"]},{"location":"Theorie/Verschluesselung.html#was-sind-die-anwendungsfalle-von-jwt","title":"Was sind die Anwendungsf\u00e4lle von JWT?","text":"<p>JWT wird h\u00e4ufig zur Verwaltung der Benutzerauthentifizierung und -autorisierung in Webanwendungen verwendet. Wenn sich ein Benutzer bei einer Anwendung anmeldet, stellt der Server ein JWT aus und sendet es an den Client zur\u00fcck. Dieses JWT kann grundlegende Informationen \u00fcber den Benutzer sowie die Rollen und Berechtigungen des Benutzers enthalten. Das JWT wird dann auf der Client-Seite gespeichert und bei nachfolgenden Anfragen zur \u00dcberpr\u00fcfung mitgesendet. Dies ist eine zustandslose Form der Authentifizierung und Autorisierung, da der Server den Sitzungsstatus nicht f\u00fcr jeden Benutzer aufrechterhalten muss.</p> <p>JWT wird auch f\u00fcr den sicheren Austausch von Daten zwischen Anwendungen und Microservices verwendet. Die in einem JWT \u00fcbertragenen Daten k\u00f6nnen verschl\u00fcsselt werden, um zu verhindern, dass Dritte sie lesen, und sie k\u00f6nnen signiert werden, um ihre Authentizit\u00e4t zu beweisen. Dies macht es zu einem sehr effizienten Mechanismus f\u00fcr den sicheren Austausch von Daten bei gleichzeitiger Wahrung des Vertrauens.</p> <ol> <li> <p>Quelle: https://docs.google.com/document/d/1aptwCFt1HZGehDyfdj1347u6_0mUR0poIwFWCBIUIK4/edit#heading=h.2ki0wrufwysh \u21a9</p> </li> <li> <p>Quelle: https://studyflix.de/informatik/symmetrische-verschlusselung-1610 \u21a9</p> </li> <li> <p>Quelle: https://studyflix.de/informatik/asymmetrische-verschlusselung-1609 \u21a9</p> </li> <li> <p>Quelle: https://www.codecademy.com/resources/blog/what-is-hashing/ \u21a9</p> </li> <li> <p>Quelle: https://github.com/21r8390/m214 \u21a9</p> </li> <li> <p>Quelle: https://blog.postman.com/what-is-jwt/ \u21a9</p> </li> </ol>","tags":["Theorie"]},{"location":"Tags.html","title":"Tags","text":"<p>Diese Webseite verf\u00fcgt \u00fcber folgende Tags:</p>"},{"location":"Tags.html#praxis","title":"Praxis","text":"<ul> <li>Error Handling</li> <li>Json Web Token</li> <li>Logging</li> <li>Passwort Hashing</li> <li>Validierung</li> <li>XSS</li> </ul>"},{"location":"Tags.html#theorie","title":"Theorie","text":"<ul> <li>OpenSSL</li> <li>Sicherheitsl\u00fccken</li> <li>Sicherheitsprinzipien</li> <li>Verschl\u00fcsselung</li> </ul>"}]}